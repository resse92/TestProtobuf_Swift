// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: DataModel.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Device: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// From official NGA iOS App or MNGA (by default).
  case apple // = 0
  case android // = 1
  case desktop // = 2
  case windowsPhone // = 3

  /// Used for custom User-Agent.
  case custom // = 100
  case UNRECOGNIZED(Int)

  public init() {
    self = .apple
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .apple
    case 1: self = .android
    case 2: self = .desktop
    case 3: self = .windowsPhone
    case 100: self = .custom
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .apple: return 0
    case .android: return 1
    case .desktop: return 2
    case .windowsPhone: return 3
    case .custom: return 100
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Device: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Device] = [
    .apple,
    .android,
    .desktop,
    .windowsPhone,
    .custom,
  ]
}

#endif  // swift(>=4.2)

public enum VoteState: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case none // = 0
  case up // = 1
  case down // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .up
    case 2: self = .down
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .up: return 1
    case .down: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VoteState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [VoteState] = [
    .none,
    .up,
    .down,
  ]
}

#endif  // swift(>=4.2)

public enum CacheType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case all // = 0
  case topicHistory // = 1
  case topicDetails // = 2
  case notification // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .all
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .all
    case 1: self = .topicHistory
    case 2: self = .topicDetails
    case 3: self = .notification
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .all: return 0
    case .topicHistory: return 1
    case .topicDetails: return 2
    case .notification: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CacheType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CacheType] = [
    .all,
    .topicHistory,
    .topicDetails,
    .notification,
  ]
}

#endif  // swift(>=4.2)

public enum CacheOperation: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case check // = 0
  case clear // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .check
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .check
    case 1: self = .clear
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .check: return 0
    case .clear: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CacheOperation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CacheOperation] = [
    .check,
    .clear,
  ]
}

#endif  // swift(>=4.2)

/// Subject of a topic.
public struct Subject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Leading tags of the topic.
  public var tags: [String] = []

  /// Main content.
  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UserName {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Original name of a user, will always be some.
  public var normal: String = String()

  /// Anonymous representation of a user name, if exists.
  public var anonymous: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Topic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// `tid` from NGA.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var subjectContent: String {
    get {return _storage._subjectContent}
    set {_uniqueStorage()._subjectContent = newValue}
  }

  public var subject: Subject {
    get {return _storage._subject ?? Subject()}
    set {_uniqueStorage()._subject = newValue}
  }
  /// Returns true if `subject` has been explicitly set.
  public var hasSubject: Bool {return _storage._subject != nil}
  /// Clears the value of `subject`. Subsequent reads from it will return its default value.
  public mutating func clearSubject() {_uniqueStorage()._subject = nil}

  public var authorID: String {
    get {return _storage._authorID}
    set {_uniqueStorage()._authorID = newValue}
  }

  public var authorNameRaw: String {
    get {return _storage._authorNameRaw}
    set {_uniqueStorage()._authorNameRaw = newValue}
  }

  public var authorName: UserName {
    get {return _storage._authorName ?? UserName()}
    set {_uniqueStorage()._authorName = newValue}
  }
  /// Returns true if `authorName` has been explicitly set.
  public var hasAuthorName: Bool {return _storage._authorName != nil}
  /// Clears the value of `authorName`. Subsequent reads from it will return its default value.
  public mutating func clearAuthorName() {_uniqueStorage()._authorName = nil}

  /// Timestamp of the topic's initial posting.
  public var postDate: UInt64 {
    get {return _storage._postDate}
    set {_uniqueStorage()._postDate = newValue}
  }

  /// Timestamp of the topic's last reply from others.
  public var lastPostDate: UInt64 {
    get {return _storage._lastPostDate}
    set {_uniqueStorage()._lastPostDate = newValue}
  }

  public var repliesNum: UInt32 {
    get {return _storage._repliesNum}
    set {_uniqueStorage()._repliesNum = newValue}
  }

  /// The direct parent forum of this topic, if
  public var parentForum: Forum {
    get {return _storage._parentForum ?? Forum()}
    set {_uniqueStorage()._parentForum = newValue}
  }
  /// Returns true if `parentForum` has been explicitly set.
  public var hasParentForum: Bool {return _storage._parentForum != nil}
  /// Clears the value of `parentForum`. Subsequent reads from it will return its default value.
  public mutating func clearParentForum() {_uniqueStorage()._parentForum = nil}

  /// it's not the exactly requested one.
  public var fav: String {
    get {return _storage._fav ?? String()}
    set {_uniqueStorage()._fav = newValue}
  }
  /// Returns true if `fav` has been explicitly set.
  public var hasFav: Bool {return _storage._fav != nil}
  /// Clears the value of `fav`. Subsequent reads from it will return its default value.
  public mutating func clearFav() {_uniqueStorage()._fav = nil}

  /// or expired, if it's favored before
  public var isFavored: Bool {
    get {return _storage._isFavored}
    set {_uniqueStorage()._isFavored = newValue}
  }

  public var repliesNumLastVisit: UInt32 {
    get {return _storage._repliesNumLastVisit ?? 0}
    set {_uniqueStorage()._repliesNumLastVisit = newValue}
  }
  /// Returns true if `repliesNumLastVisit` has been explicitly set.
  public var hasRepliesNumLastVisit: Bool {return _storage._repliesNumLastVisit != nil}
  /// Clears the value of `repliesNumLastVisit`. Subsequent reads from it will return its default value.
  public mutating func clearRepliesNumLastVisit() {_uniqueStorage()._repliesNumLastVisit = nil}

  /// The id of the topic's parent forum, mainly used for
  public var fid: String {
    get {return _storage._fid}
    set {_uniqueStorage()._fid = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var name: UserName {
    get {return _name ?? UserName()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var avatarURL: String = String()

  /// The timestamp of the user's registration.
  public var regDate: UInt64 = 0

  public var postNum: UInt32 = 0

  /// Should be resolved as `fame / 10`.
  public var fame: Int64 = 0

  public var signature: PostContent {
    get {return _signature ?? PostContent()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var nameRaw: String = String()

  /// Whether the user is temporarily banned by NGA.
  public var mute: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: UserName? = nil
  fileprivate var _signature: PostContent? = nil
}

public struct PostId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of this post. If `pid` is 0, it's the main floor of
  public var pid: String = String()

  /// this `topic`. Otherwise, it's globally unique.
  public var tid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Post {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: PostId {
    get {return _storage._id ?? PostId()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  /// This might be inaccurate if it's from a special topic
  public var floor: UInt32 {
    get {return _storage._floor}
    set {_uniqueStorage()._floor = newValue}
  }

  /// details request with other arguments specified.
  public var authorID: String {
    get {return _storage._authorID}
    set {_uniqueStorage()._authorID = newValue}
  }

  public var content: PostContent {
    get {return _storage._content ?? PostContent()}
    set {_uniqueStorage()._content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return _storage._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {_uniqueStorage()._content = nil}

  /// The timestamp of the posting.
  public var postDate: UInt64 {
    get {return _storage._postDate}
    set {_uniqueStorage()._postDate = newValue}
  }

  /// The number of upvotes.
  public var score: UInt32 {
    get {return _storage._score}
    set {_uniqueStorage()._score = newValue}
  }

  /// The vote state cached from current client before.
  public var voteState: VoteState {
    get {return _storage._voteState}
    set {_uniqueStorage()._voteState = newValue}
  }

  /// Hot replies only exist in the main floor.
  public var hotReplies: [Post] {
    get {return _storage._hotReplies}
    set {_uniqueStorage()._hotReplies = newValue}
  }

  /// Inline replies.
  public var comments: [Post] {
    get {return _storage._comments}
    set {_uniqueStorage()._comments = newValue}
  }

  public var device: Device {
    get {return _storage._device}
    set {_uniqueStorage()._device = newValue}
  }

  /// This post has been altered if it's not empty.
  public var alterInfo: String {
    get {return _storage._alterInfo}
    set {_uniqueStorage()._alterInfo = newValue}
  }

  /// The page which this post belongs to.
  public var atPage: UInt32 {
    get {return _storage._atPage}
    set {_uniqueStorage()._atPage = newValue}
  }

  public var attachments: [Attachment] {
    get {return _storage._attachments}
    set {_uniqueStorage()._attachments = newValue}
  }

  /// The id of the post's parent forum, mainly used for
  public var fid: String {
    get {return _storage._fid}
    set {_uniqueStorage()._fid = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Post with much less information, used for posts of some user.
public struct LightPost {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: PostId {
    get {return _id ?? PostId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var authorID: String = String()

  public var content: PostContent {
    get {return _content ?? PostContent()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  public var postDate: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: PostId? = nil
  fileprivate var _content: PostContent? = nil
}

/// Combination of `Topic` and `LightPost`, used for posts of some user.
public struct TopicWithLightPost {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: Topic {
    get {return _topic ?? Topic()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  public var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  public mutating func clearTopic() {self._topic = nil}

  public var post: LightPost {
    get {return _post ?? LightPost()}
    set {_post = newValue}
  }
  /// Returns true if `post` has been explicitly set.
  public var hasPost: Bool {return self._post != nil}
  /// Clears the value of `post`. Subsequent reads from it will return its default value.
  public mutating func clearPost() {self._post = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _topic: Topic? = nil
  fileprivate var _post: LightPost? = nil
}

/// Children of a parent forum, can be subscribed or unsubscribed.
public struct Subforum {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Info of the subforum.
  public var forum: Forum {
    get {return _forum ?? Forum()}
    set {_forum = newValue}
  }
  /// Returns true if `forum` has been explicitly set.
  public var hasForum: Bool {return self._forum != nil}
  /// Clears the value of `forum`. Subsequent reads from it will return its default value.
  public mutating func clearForum() {self._forum = nil}

  /// ID used for sending request to (un)subcribe self.
  public var filterID: String = String()

  public var attributes: UInt64 = 0

  /// Whether this subforum is able to be unsubscribed.
  public var filterable: Bool = false

  /// Whether this subforum is subscribed in its parent forum.
  public var selected: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _forum: Forum? = nil
}

public struct Category {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var name: String = String()

  public var forums: [Forum] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForumId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// todo: no oneof
  public var id: ForumId.OneOf_ID? = nil

  public var fid: String {
    get {
      if case .fid(let v)? = id {return v}
      return String()
    }
    set {id = .fid(newValue)}
  }

  public var stid: String {
    get {
      if case .stid(let v)? = id {return v}
      return String()
    }
    set {id = .stid(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// todo: no oneof
  public enum OneOf_ID: Equatable {
    case fid(String)
    case stid(String)

  #if !swift(>=4.1)
    public static func ==(lhs: ForumId.OneOf_ID, rhs: ForumId.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.fid, .fid): return {
        guard case .fid(let l) = lhs, case .fid(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stid, .stid): return {
        guard case .stid(let l) = lhs, case .stid(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Forum {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: ForumId {
    get {return _id ?? ForumId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var name: String = String()

  public var info: String = String()

  public var iconURL: String = String()

  public var toppedTopicID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: ForumId? = nil
}

/// Part of rich contents.
public struct Span {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Span.OneOf_Value? = nil

  public var plain: Span.Plain {
    get {
      if case .plain(let v)? = value {return v}
      return Span.Plain()
    }
    set {value = .plain(newValue)}
  }

  public var breakLine: Span.BreakLine {
    get {
      if case .breakLine(let v)? = value {return v}
      return Span.BreakLine()
    }
    set {value = .breakLine(newValue)}
  }

  public var sticker: Span.Sticker {
    get {
      if case .sticker(let v)? = value {return v}
      return Span.Sticker()
    }
    set {value = .sticker(newValue)}
  }

  public var tagged: Span.Tagged {
    get {
      if case .tagged(let v)? = value {return v}
      return Span.Tagged()
    }
    set {value = .tagged(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case plain(Span.Plain)
    case breakLine(Span.BreakLine)
    case sticker(Span.Sticker)
    case tagged(Span.Tagged)

  #if !swift(>=4.1)
    public static func ==(lhs: Span.OneOf_Value, rhs: Span.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.plain, .plain): return {
        guard case .plain(let l) = lhs, case .plain(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.breakLine, .breakLine): return {
        guard case .breakLine(let l) = lhs, case .breakLine(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sticker, .sticker): return {
        guard case .sticker(let l) = lhs, case .sticker(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tagged, .tagged): return {
        guard case .tagged(let l) = lhs, case .tagged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Plain {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var text: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct BreakLine {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Sticker {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Tagged {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var tag: String = String()

    public var attributes: [String] = []

    public var complexAttributes: [String] = []

    /// Children span nodes.
    public var spans: [Span] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Rich content parsed from bbcode.
public struct PostContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var spans: [Span] = []

  /// Raw bbcode representation of this content.
  public var raw: String = String()

  /// Parse error.
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Attachment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var url: String = String()

  public var size: UInt64 = 0

  public var type: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Configuration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path to an App-local writable directory.
  public var documentDirPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct AuthInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: String = String()

  public var token: String = String()

  public var device: Int32 = 0

  /// Cached user name from last authentication.
  public var cachedName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RequestOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var baseURLV2: String = String()

  public var device: Device = .apple

  public var mockBaseURLV2: String = String()

  public var randomUa: Bool = false

  /// Only used when `device` is `CUSTOM` and `random_ua`
  public var customUa: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TopicSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topicSnapshot: Topic {
    get {return _topicSnapshot ?? Topic()}
    set {_topicSnapshot = newValue}
  }
  /// Returns true if `topicSnapshot` has been explicitly set.
  public var hasTopicSnapshot: Bool {return self._topicSnapshot != nil}
  /// Clears the value of `topicSnapshot`. Subsequent reads from it will return its default value.
  public mutating func clearTopicSnapshot() {self._topicSnapshot = nil}

  public var timestamp: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _topicSnapshot: Topic? = nil
}

public struct ErrorMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String = String()

  public var info: String = String()

  public var detailed: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Extra info for posting action from fetching step, which should be passed
/// verbatim when do posting.
public struct PostReplyVerbatim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether this modification can only be appendent due
  public var modifyAppend: Bool = false

  /// to exceeding of date, or in-place.
  public var auth: String = String()

  /// URL where attachments should be uploaded to.
  public var attachURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PostReplyAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var operation: PostReplyAction.Operation = .reply

  /// Used if operation is not `NEW`.
  public var postID: PostId {
    get {return _postID ?? PostId()}
    set {_postID = newValue}
  }
  /// Returns true if `postID` has been explicitly set.
  public var hasPostID: Bool {return self._postID != nil}
  /// Clears the value of `postID`. Subsequent reads from it will return its default value.
  public mutating func clearPostID() {self._postID = nil}

  /// Used if operation is `NEW`.
  public var forumID: ForumId {
    get {return _forumID ?? ForumId()}
    set {_forumID = newValue}
  }
  /// Returns true if `forumID` has been explicitly set.
  public var hasForumID: Bool {return self._forumID != nil}
  /// Clears the value of `forumID`. Subsequent reads from it will return its default value.
  public mutating func clearForumID() {self._forumID = nil}

  public var verbatim: PostReplyVerbatim {
    get {return _verbatim ?? PostReplyVerbatim()}
    set {_verbatim = newValue}
  }
  /// Returns true if `verbatim` has been explicitly set.
  public var hasVerbatim: Bool {return self._verbatim != nil}
  /// Clears the value of `verbatim`. Subsequent reads from it will return its default value.
  public mutating func clearVerbatim() {self._verbatim = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Operation: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case reply // = 0
    case quote // = 1
    case modify // = 2
    case comment // = 3
    case new // = 4
    case report // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .reply
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .reply
      case 1: self = .quote
      case 2: self = .modify
      case 3: self = .comment
      case 4: self = .new
      case 5: self = .report
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .reply: return 0
      case .quote: return 1
      case .modify: return 2
      case .comment: return 3
      case .new: return 4
      case .report: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _postID: PostId? = nil
  fileprivate var _forumID: ForumId? = nil
  fileprivate var _verbatim: PostReplyVerbatim? = nil
}

#if swift(>=4.2)

extension PostReplyAction.Operation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PostReplyAction.Operation] = [
    .reply,
    .quote,
    .modify,
    .comment,
    .new,
    .report,
  ]
}

#endif  // swift(>=4.2)

public struct Notification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var type: Notification.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var otherUser: User {
    get {return _storage._otherUser ?? User()}
    set {_uniqueStorage()._otherUser = newValue}
  }
  /// Returns true if `otherUser` has been explicitly set.
  public var hasOtherUser: Bool {return _storage._otherUser != nil}
  /// Clears the value of `otherUser`. Subsequent reads from it will return its default value.
  public mutating func clearOtherUser() {_uniqueStorage()._otherUser = nil}

  /// ID of our post.
  public var postID: PostId {
    get {return _storage._postID ?? PostId()}
    set {_uniqueStorage()._postID = newValue}
  }
  /// Returns true if `postID` has been explicitly set.
  public var hasPostID: Bool {return _storage._postID != nil}
  /// Clears the value of `postID`. Subsequent reads from it will return its default value.
  public mutating func clearPostID() {_uniqueStorage()._postID = nil}

  /// ID of other's post.
  public var otherPostID: PostId {
    get {return _storage._otherPostID ?? PostId()}
    set {_uniqueStorage()._otherPostID = newValue}
  }
  /// Returns true if `otherPostID` has been explicitly set.
  public var hasOtherPostID: Bool {return _storage._otherPostID != nil}
  /// Clears the value of `otherPostID`. Subsequent reads from it will return its default value.
  public mutating func clearOtherPostID() {_uniqueStorage()._otherPostID = nil}

  public var topicSubject: Subject {
    get {return _storage._topicSubject ?? Subject()}
    set {_uniqueStorage()._topicSubject = newValue}
  }
  /// Returns true if `topicSubject` has been explicitly set.
  public var hasTopicSubject: Bool {return _storage._topicSubject != nil}
  /// Clears the value of `topicSubject`. Subsequent reads from it will return its default value.
  public mutating func clearTopicSubject() {_uniqueStorage()._topicSubject = nil}

  public var timestamp: UInt64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  /// The page of other's post in the topic.
  public var page: UInt32 {
    get {return _storage._page}
    set {_uniqueStorage()._page = newValue}
  }

  /// Whether this notification has been read.
  public var read: Bool {
    get {return _storage._read}
    set {_uniqueStorage()._read = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// One replies to user's topic.
    case replyTopic // = 1

    /// One replies to user's post.
    case replyPost // = 2

    /// One starts a new short message.
    case shortMessageStart // = 10

    /// One replies to a short message.
    case shortMessage // = 11

    /// User's post receives some votes.
    case vote // = 17
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .replyTopic
      case 2: self = .replyPost
      case 10: self = .shortMessageStart
      case 11: self = .shortMessage
      case 17: self = .vote
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .replyTopic: return 1
      case .replyPost: return 2
      case .shortMessageStart: return 10
      case .shortMessage: return 11
      case .vote: return 17
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Notification.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Notification.TypeEnum] = [
    .unknown,
    .replyTopic,
    .replyPost,
    .shortMessageStart,
    .shortMessage,
    .vote,
  ]
}

#endif  // swift(>=4.2)

public struct BlockWord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var word: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Attachments that have been already uploaded, but not posted yet.
public struct PostAttachment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var url: String = String()

  /// Verification code for posting this attachment.
  public var check: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Info of one short message conversation, contains a list of posts.
public struct ShortMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var subject: String = String()

  public var fromID: String = String()

  public var fromName: String = String()

  public var postDate: UInt64 = 0

  public var lastPostDate: UInt64 = 0

  public var postNum: UInt32 = 0

  public var ids: [String] = []

  public var userNames: [UserName] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ShortMessagePost {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var authorID: String = String()

  public var subject: String = String()

  public var content: PostContent {
    get {return _content ?? PostContent()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  public var postDate: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _content: PostContent? = nil
}

public struct ShortMessagePostAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var operation: ShortMessagePostAction.Operation = .reply

  /// Message id to reply to, used if operation is `REPLY`.
  public var mid: String = String()

  /// UID to send to, used if operation is `NEW_SINGLE_TO`.
  public var singleTo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Operation: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case reply // = 0
    case new // = 1

    /// Send to exactly single user.
    case newSingleTo // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .reply
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .reply
      case 1: self = .new
      case 2: self = .newSingleTo
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .reply: return 0
      case .new: return 1
      case .newSingleTo: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension ShortMessagePostAction.Operation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ShortMessagePostAction.Operation] = [
    .reply,
    .new,
    .newSingleTo,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Device: @unchecked Sendable {}
extension VoteState: @unchecked Sendable {}
extension CacheType: @unchecked Sendable {}
extension CacheOperation: @unchecked Sendable {}
extension Subject: @unchecked Sendable {}
extension UserName: @unchecked Sendable {}
extension Topic: @unchecked Sendable {}
extension User: @unchecked Sendable {}
extension PostId: @unchecked Sendable {}
extension Post: @unchecked Sendable {}
extension LightPost: @unchecked Sendable {}
extension TopicWithLightPost: @unchecked Sendable {}
extension Subforum: @unchecked Sendable {}
extension Category: @unchecked Sendable {}
extension ForumId: @unchecked Sendable {}
extension ForumId.OneOf_ID: @unchecked Sendable {}
extension Forum: @unchecked Sendable {}
extension Span: @unchecked Sendable {}
extension Span.OneOf_Value: @unchecked Sendable {}
extension Span.Plain: @unchecked Sendable {}
extension Span.BreakLine: @unchecked Sendable {}
extension Span.Sticker: @unchecked Sendable {}
extension Span.Tagged: @unchecked Sendable {}
extension PostContent: @unchecked Sendable {}
extension Attachment: @unchecked Sendable {}
extension Configuration: @unchecked Sendable {}
extension AuthInfo: @unchecked Sendable {}
extension RequestOption: @unchecked Sendable {}
extension TopicSnapshot: @unchecked Sendable {}
extension ErrorMessage: @unchecked Sendable {}
extension PostReplyVerbatim: @unchecked Sendable {}
extension PostReplyAction: @unchecked Sendable {}
extension PostReplyAction.Operation: @unchecked Sendable {}
extension Notification: @unchecked Sendable {}
extension Notification.TypeEnum: @unchecked Sendable {}
extension BlockWord: @unchecked Sendable {}
extension PostAttachment: @unchecked Sendable {}
extension ShortMessage: @unchecked Sendable {}
extension ShortMessagePost: @unchecked Sendable {}
extension ShortMessagePostAction: @unchecked Sendable {}
extension ShortMessagePostAction.Operation: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Device: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APPLE"),
    1: .same(proto: "ANDROID"),
    2: .same(proto: "DESKTOP"),
    3: .same(proto: "WINDOWS_PHONE"),
    100: .same(proto: "CUSTOM"),
  ]
}

extension VoteState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "UP"),
    2: .same(proto: "DOWN"),
  ]
}

extension CacheType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "TOPIC_HISTORY"),
    2: .same(proto: "TOPIC_DETAILS"),
    3: .same(proto: "NOTIFICATION"),
  ]
}

extension CacheOperation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHECK"),
    1: .same(proto: "CLEAR"),
  ]
}

extension Subject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Subject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tags"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Subject, rhs: Subject) -> Bool {
    if lhs.tags != rhs.tags {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserName"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "normal"),
    2: .same(proto: "anonymous"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.normal) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.anonymous) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.normal.isEmpty {
      try visitor.visitSingularStringField(value: self.normal, fieldNumber: 1)
    }
    if !self.anonymous.isEmpty {
      try visitor.visitSingularStringField(value: self.anonymous, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserName, rhs: UserName) -> Bool {
    if lhs.normal != rhs.normal {return false}
    if lhs.anonymous != rhs.anonymous {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Topic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Topic"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    8: .same(proto: "tags"),
    9: .standard(proto: "subject_content"),
    2: .same(proto: "subject"),
    3: .standard(proto: "author_id"),
    4: .standard(proto: "author_name_raw"),
    15: .standard(proto: "author_name"),
    5: .standard(proto: "post_date"),
    6: .standard(proto: "last_post_date"),
    7: .standard(proto: "replies_num"),
    10: .standard(proto: "parent_forum"),
    11: .same(proto: "fav"),
    12: .standard(proto: "is_favored"),
    13: .standard(proto: "replies_num_last_visit"),
    14: .same(proto: "fid"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _tags: [String] = []
    var _subjectContent: String = String()
    var _subject: Subject? = nil
    var _authorID: String = String()
    var _authorNameRaw: String = String()
    var _authorName: UserName? = nil
    var _postDate: UInt64 = 0
    var _lastPostDate: UInt64 = 0
    var _repliesNum: UInt32 = 0
    var _parentForum: Forum? = nil
    var _fav: String? = nil
    var _isFavored: Bool = false
    var _repliesNumLastVisit: UInt32? = nil
    var _fid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _tags = source._tags
      _subjectContent = source._subjectContent
      _subject = source._subject
      _authorID = source._authorID
      _authorNameRaw = source._authorNameRaw
      _authorName = source._authorName
      _postDate = source._postDate
      _lastPostDate = source._lastPostDate
      _repliesNum = source._repliesNum
      _parentForum = source._parentForum
      _fav = source._fav
      _isFavored = source._isFavored
      _repliesNumLastVisit = source._repliesNumLastVisit
      _fid = source._fid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._subject) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._authorID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._authorNameRaw) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._postDate) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._lastPostDate) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._repliesNum) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._subjectContent) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._parentForum) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._fav) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._isFavored) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._repliesNumLastVisit) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._fid) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._authorName) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._subject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._authorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authorID, fieldNumber: 3)
      }
      if !_storage._authorNameRaw.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authorNameRaw, fieldNumber: 4)
      }
      if _storage._postDate != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._postDate, fieldNumber: 5)
      }
      if _storage._lastPostDate != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._lastPostDate, fieldNumber: 6)
      }
      if _storage._repliesNum != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._repliesNum, fieldNumber: 7)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 8)
      }
      if !_storage._subjectContent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subjectContent, fieldNumber: 9)
      }
      try { if let v = _storage._parentForum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._fav {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      } }()
      if _storage._isFavored != false {
        try visitor.visitSingularBoolField(value: _storage._isFavored, fieldNumber: 12)
      }
      try { if let v = _storage._repliesNumLastVisit {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
      } }()
      if !_storage._fid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fid, fieldNumber: 14)
      }
      try { if let v = _storage._authorName {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Topic, rhs: Topic) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._subjectContent != rhs_storage._subjectContent {return false}
        if _storage._subject != rhs_storage._subject {return false}
        if _storage._authorID != rhs_storage._authorID {return false}
        if _storage._authorNameRaw != rhs_storage._authorNameRaw {return false}
        if _storage._authorName != rhs_storage._authorName {return false}
        if _storage._postDate != rhs_storage._postDate {return false}
        if _storage._lastPostDate != rhs_storage._lastPostDate {return false}
        if _storage._repliesNum != rhs_storage._repliesNum {return false}
        if _storage._parentForum != rhs_storage._parentForum {return false}
        if _storage._fav != rhs_storage._fav {return false}
        if _storage._isFavored != rhs_storage._isFavored {return false}
        if _storage._repliesNumLastVisit != rhs_storage._repliesNumLastVisit {return false}
        if _storage._fid != rhs_storage._fid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "User"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    8: .same(proto: "name"),
    3: .standard(proto: "avatar_url"),
    4: .standard(proto: "reg_date"),
    5: .standard(proto: "post_num"),
    6: .same(proto: "fame"),
    7: .same(proto: "signature"),
    2: .standard(proto: "name_raw"),
    9: .same(proto: "mute"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nameRaw) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.regDate) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.postNum) }()
      case 6: try { try decoder.decodeSingularSInt64Field(value: &self.fame) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.mute) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.nameRaw.isEmpty {
      try visitor.visitSingularStringField(value: self.nameRaw, fieldNumber: 2)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 3)
    }
    if self.regDate != 0 {
      try visitor.visitSingularUInt64Field(value: self.regDate, fieldNumber: 4)
    }
    if self.postNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.postNum, fieldNumber: 5)
    }
    if self.fame != 0 {
      try visitor.visitSingularSInt64Field(value: self.fame, fieldNumber: 6)
    }
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.mute != false {
      try visitor.visitSingularBoolField(value: self.mute, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: User, rhs: User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._name != rhs._name {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.regDate != rhs.regDate {return false}
    if lhs.postNum != rhs.postNum {return false}
    if lhs.fame != rhs.fame {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.nameRaw != rhs.nameRaw {return false}
    if lhs.mute != rhs.mute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PostId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PostId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pid"),
    2: .same(proto: "tid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pid.isEmpty {
      try visitor.visitSingularStringField(value: self.pid, fieldNumber: 1)
    }
    if !self.tid.isEmpty {
      try visitor.visitSingularStringField(value: self.tid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PostId, rhs: PostId) -> Bool {
    if lhs.pid != rhs.pid {return false}
    if lhs.tid != rhs.tid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Post: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Post"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "id"),
    1: .same(proto: "floor"),
    2: .standard(proto: "author_id"),
    3: .same(proto: "content"),
    4: .standard(proto: "post_date"),
    5: .same(proto: "score"),
    7: .standard(proto: "vote_state"),
    8: .standard(proto: "hot_replies"),
    12: .same(proto: "comments"),
    9: .same(proto: "device"),
    10: .standard(proto: "alter_info"),
    11: .standard(proto: "at_page"),
    13: .same(proto: "attachments"),
    14: .same(proto: "fid"),
  ]

  fileprivate class _StorageClass {
    var _id: PostId? = nil
    var _floor: UInt32 = 0
    var _authorID: String = String()
    var _content: PostContent? = nil
    var _postDate: UInt64 = 0
    var _score: UInt32 = 0
    var _voteState: VoteState = .none
    var _hotReplies: [Post] = []
    var _comments: [Post] = []
    var _device: Device = .apple
    var _alterInfo: String = String()
    var _atPage: UInt32 = 0
    var _attachments: [Attachment] = []
    var _fid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _floor = source._floor
      _authorID = source._authorID
      _content = source._content
      _postDate = source._postDate
      _score = source._score
      _voteState = source._voteState
      _hotReplies = source._hotReplies
      _comments = source._comments
      _device = source._device
      _alterInfo = source._alterInfo
      _atPage = source._atPage
      _attachments = source._attachments
      _fid = source._fid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._floor) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._authorID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._content) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._postDate) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._score) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._voteState) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._hotReplies) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._device) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._alterInfo) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._atPage) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._comments) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._attachments) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._fid) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._floor != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._floor, fieldNumber: 1)
      }
      if !_storage._authorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authorID, fieldNumber: 2)
      }
      try { if let v = _storage._content {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._postDate != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._postDate, fieldNumber: 4)
      }
      if _storage._score != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._score, fieldNumber: 5)
      }
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._voteState != .none {
        try visitor.visitSingularEnumField(value: _storage._voteState, fieldNumber: 7)
      }
      if !_storage._hotReplies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hotReplies, fieldNumber: 8)
      }
      if _storage._device != .apple {
        try visitor.visitSingularEnumField(value: _storage._device, fieldNumber: 9)
      }
      if !_storage._alterInfo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._alterInfo, fieldNumber: 10)
      }
      if _storage._atPage != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._atPage, fieldNumber: 11)
      }
      if !_storage._comments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._comments, fieldNumber: 12)
      }
      if !_storage._attachments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._attachments, fieldNumber: 13)
      }
      if !_storage._fid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fid, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Post, rhs: Post) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._floor != rhs_storage._floor {return false}
        if _storage._authorID != rhs_storage._authorID {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._postDate != rhs_storage._postDate {return false}
        if _storage._score != rhs_storage._score {return false}
        if _storage._voteState != rhs_storage._voteState {return false}
        if _storage._hotReplies != rhs_storage._hotReplies {return false}
        if _storage._comments != rhs_storage._comments {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._alterInfo != rhs_storage._alterInfo {return false}
        if _storage._atPage != rhs_storage._atPage {return false}
        if _storage._attachments != rhs_storage._attachments {return false}
        if _storage._fid != rhs_storage._fid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LightPost: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LightPost"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "author_id"),
    3: .same(proto: "content"),
    4: .standard(proto: "post_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authorID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.postDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.authorID.isEmpty {
      try visitor.visitSingularStringField(value: self.authorID, fieldNumber: 2)
    }
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.postDate != 0 {
      try visitor.visitSingularUInt64Field(value: self.postDate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LightPost, rhs: LightPost) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.authorID != rhs.authorID {return false}
    if lhs._content != rhs._content {return false}
    if lhs.postDate != rhs.postDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TopicWithLightPost: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TopicWithLightPost"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "post"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._topic) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._post) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._post {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TopicWithLightPost, rhs: TopicWithLightPost) -> Bool {
    if lhs._topic != rhs._topic {return false}
    if lhs._post != rhs._post {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Subforum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Subforum"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .same(proto: "forum"),
    7: .standard(proto: "filter_id"),
    4: .same(proto: "attributes"),
    5: .same(proto: "filterable"),
    6: .same(proto: "selected"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.attributes) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.filterable) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.selected) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.filterID) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._forum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.attributes != 0 {
      try visitor.visitSingularUInt64Field(value: self.attributes, fieldNumber: 4)
    }
    if self.filterable != false {
      try visitor.visitSingularBoolField(value: self.filterable, fieldNumber: 5)
    }
    if self.selected != false {
      try visitor.visitSingularBoolField(value: self.selected, fieldNumber: 6)
    }
    if !self.filterID.isEmpty {
      try visitor.visitSingularStringField(value: self.filterID, fieldNumber: 7)
    }
    try { if let v = self._forum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Subforum, rhs: Subforum) -> Bool {
    if lhs._forum != rhs._forum {return false}
    if lhs.filterID != rhs.filterID {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.filterable != rhs.filterable {return false}
    if lhs.selected != rhs.selected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Category: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Category"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "forums"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.forums) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.forums.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.forums, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Category, rhs: Category) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.forums != rhs.forums {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForumId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ForumId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fid"),
    2: .same(proto: "stid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .fid(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .stid(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .fid?: try {
      guard case .fid(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .stid?: try {
      guard case .stid(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForumId, rhs: ForumId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Forum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Forum"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "info"),
    4: .standard(proto: "icon_url"),
    5: .standard(proto: "topped_topic_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.info) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.toppedTopicID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.info.isEmpty {
      try visitor.visitSingularStringField(value: self.info, fieldNumber: 3)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 4)
    }
    if !self.toppedTopicID.isEmpty {
      try visitor.visitSingularStringField(value: self.toppedTopicID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Forum, rhs: Forum) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.info != rhs.info {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.toppedTopicID != rhs.toppedTopicID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Span: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Span"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "plain"),
    2: .standard(proto: "break_line"),
    3: .same(proto: "sticker"),
    4: .same(proto: "tagged"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Span.Plain?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .plain(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .plain(v)
        }
      }()
      case 2: try {
        var v: Span.BreakLine?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .breakLine(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .breakLine(v)
        }
      }()
      case 3: try {
        var v: Span.Sticker?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .sticker(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .sticker(v)
        }
      }()
      case 4: try {
        var v: Span.Tagged?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .tagged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .tagged(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .plain?: try {
      guard case .plain(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .breakLine?: try {
      guard case .breakLine(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .sticker?: try {
      guard case .sticker(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .tagged?: try {
      guard case .tagged(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Span, rhs: Span) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Span.Plain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Span.protoMessageName + ".Plain"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Span.Plain, rhs: Span.Plain) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Span.BreakLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Span.protoMessageName + ".BreakLine"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Span.BreakLine, rhs: Span.BreakLine) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Span.Sticker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Span.protoMessageName + ".Sticker"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Span.Sticker, rhs: Span.Sticker) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Span.Tagged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Span.protoMessageName + ".Tagged"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .same(proto: "attributes"),
    4: .standard(proto: "complex_attributes"),
    3: .same(proto: "spans"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tag) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.attributes) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.spans) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.complexAttributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 1)
    }
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.attributes, fieldNumber: 2)
    }
    if !self.spans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spans, fieldNumber: 3)
    }
    if !self.complexAttributes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.complexAttributes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Span.Tagged, rhs: Span.Tagged) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.complexAttributes != rhs.complexAttributes {return false}
    if lhs.spans != rhs.spans {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PostContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PostContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spans"),
    2: .same(proto: "raw"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.spans) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.raw) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.spans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spans, fieldNumber: 1)
    }
    if !self.raw.isEmpty {
      try visitor.visitSingularStringField(value: self.raw, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PostContent, rhs: PostContent) -> Bool {
    if lhs.spans != rhs.spans {return false}
    if lhs.raw != rhs.raw {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Attachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Attachment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "size"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Attachment, rhs: Attachment) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.size != rhs.size {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Configuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Configuration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "document_dir_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.documentDirPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.documentDirPath.isEmpty {
      try visitor.visitSingularStringField(value: self.documentDirPath, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Configuration, rhs: Configuration) -> Bool {
    if lhs.documentDirPath != rhs.documentDirPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AuthInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AuthInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "token"),
    3: .same(proto: "device"),
    4: .standard(proto: "cached_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.device) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cachedName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    if self.device != 0 {
      try visitor.visitSingularInt32Field(value: self.device, fieldNumber: 3)
    }
    if !self.cachedName.isEmpty {
      try visitor.visitSingularStringField(value: self.cachedName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AuthInfo, rhs: AuthInfo) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.token != rhs.token {return false}
    if lhs.device != rhs.device {return false}
    if lhs.cachedName != rhs.cachedName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RequestOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RequestOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_url_v2"),
    2: .same(proto: "device"),
    3: .standard(proto: "mock_base_url_v2"),
    4: .standard(proto: "random_ua"),
    5: .standard(proto: "custom_ua"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.baseURLV2) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.device) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mockBaseURLV2) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.randomUa) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.customUa) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.baseURLV2.isEmpty {
      try visitor.visitSingularStringField(value: self.baseURLV2, fieldNumber: 1)
    }
    if self.device != .apple {
      try visitor.visitSingularEnumField(value: self.device, fieldNumber: 2)
    }
    if !self.mockBaseURLV2.isEmpty {
      try visitor.visitSingularStringField(value: self.mockBaseURLV2, fieldNumber: 3)
    }
    if self.randomUa != false {
      try visitor.visitSingularBoolField(value: self.randomUa, fieldNumber: 4)
    }
    if !self.customUa.isEmpty {
      try visitor.visitSingularStringField(value: self.customUa, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RequestOption, rhs: RequestOption) -> Bool {
    if lhs.baseURLV2 != rhs.baseURLV2 {return false}
    if lhs.device != rhs.device {return false}
    if lhs.mockBaseURLV2 != rhs.mockBaseURLV2 {return false}
    if lhs.randomUa != rhs.randomUa {return false}
    if lhs.customUa != rhs.customUa {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TopicSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TopicSnapshot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "topic_snapshot"),
    2: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._topicSnapshot) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topicSnapshot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TopicSnapshot, rhs: TopicSnapshot) -> Bool {
    if lhs._topicSnapshot != rhs._topicSnapshot {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ErrorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ErrorMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "info"),
    3: .same(proto: "detailed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.info) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.detailed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.info.isEmpty {
      try visitor.visitSingularStringField(value: self.info, fieldNumber: 2)
    }
    if !self.detailed.isEmpty {
      try visitor.visitSingularStringField(value: self.detailed, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ErrorMessage, rhs: ErrorMessage) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.info != rhs.info {return false}
    if lhs.detailed != rhs.detailed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PostReplyVerbatim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PostReplyVerbatim"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "modify_append"),
    2: .same(proto: "auth"),
    3: .standard(proto: "attach_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.modifyAppend) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.auth) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.attachURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.modifyAppend != false {
      try visitor.visitSingularBoolField(value: self.modifyAppend, fieldNumber: 1)
    }
    if !self.auth.isEmpty {
      try visitor.visitSingularStringField(value: self.auth, fieldNumber: 2)
    }
    if !self.attachURL.isEmpty {
      try visitor.visitSingularStringField(value: self.attachURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PostReplyVerbatim, rhs: PostReplyVerbatim) -> Bool {
    if lhs.modifyAppend != rhs.modifyAppend {return false}
    if lhs.auth != rhs.auth {return false}
    if lhs.attachURL != rhs.attachURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PostReplyAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PostReplyAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .standard(proto: "post_id"),
    3: .standard(proto: "forum_id"),
    4: .same(proto: "verbatim"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._postID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._forumID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._verbatim) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operation != .reply {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 1)
    }
    try { if let v = self._postID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._forumID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._verbatim {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PostReplyAction, rhs: PostReplyAction) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs._postID != rhs._postID {return false}
    if lhs._forumID != rhs._forumID {return false}
    if lhs._verbatim != rhs._verbatim {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PostReplyAction.Operation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REPLY"),
    1: .same(proto: "QUOTE"),
    2: .same(proto: "MODIFY"),
    3: .same(proto: "COMMENT"),
    4: .same(proto: "NEW"),
    5: .same(proto: "REPORT"),
  ]
}

extension Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Notification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    9: .same(proto: "id"),
    1: .same(proto: "type"),
    2: .standard(proto: "other_user"),
    3: .standard(proto: "post_id"),
    4: .standard(proto: "other_post_id"),
    5: .standard(proto: "topic_subject"),
    6: .same(proto: "timestamp"),
    7: .same(proto: "page"),
    8: .same(proto: "read"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _type: Notification.TypeEnum = .unknown
    var _otherUser: User? = nil
    var _postID: PostId? = nil
    var _otherPostID: PostId? = nil
    var _topicSubject: Subject? = nil
    var _timestamp: UInt64 = 0
    var _page: UInt32 = 0
    var _read: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _otherUser = source._otherUser
      _postID = source._postID
      _otherPostID = source._otherPostID
      _topicSubject = source._topicSubject
      _timestamp = source._timestamp
      _page = source._page
      _read = source._read
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._otherUser) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._postID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._otherPostID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._topicSubject) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._timestamp) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._page) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._read) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      try { if let v = _storage._otherUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._postID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._otherPostID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._topicSubject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._timestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._timestamp, fieldNumber: 6)
      }
      if _storage._page != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._page, fieldNumber: 7)
      }
      if _storage._read != false {
        try visitor.visitSingularBoolField(value: _storage._read, fieldNumber: 8)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Notification, rhs: Notification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._otherUser != rhs_storage._otherUser {return false}
        if _storage._postID != rhs_storage._postID {return false}
        if _storage._otherPostID != rhs_storage._otherPostID {return false}
        if _storage._topicSubject != rhs_storage._topicSubject {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._read != rhs_storage._read {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Notification.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "REPLY_TOPIC"),
    2: .same(proto: "REPLY_POST"),
    10: .same(proto: "SHORT_MESSAGE_START"),
    11: .same(proto: "SHORT_MESSAGE"),
    17: .same(proto: "VOTE"),
  ]
}

extension BlockWord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BlockWord"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "word"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.word) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.word.isEmpty {
      try visitor.visitSingularStringField(value: self.word, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlockWord, rhs: BlockWord) -> Bool {
    if lhs.word != rhs.word {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PostAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PostAttachment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
    3: .same(proto: "check"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.check) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if !self.check.isEmpty {
      try visitor.visitSingularStringField(value: self.check, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PostAttachment, rhs: PostAttachment) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.check != rhs.check {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShortMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ShortMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "subject"),
    3: .standard(proto: "from_id"),
    4: .standard(proto: "from_name"),
    5: .standard(proto: "post_date"),
    6: .standard(proto: "last_post_date"),
    7: .standard(proto: "post_num"),
    8: .same(proto: "ids"),
    9: .standard(proto: "user_names"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subject) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fromID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fromName) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.postDate) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.lastPostDate) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.postNum) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.userNames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 2)
    }
    if !self.fromID.isEmpty {
      try visitor.visitSingularStringField(value: self.fromID, fieldNumber: 3)
    }
    if !self.fromName.isEmpty {
      try visitor.visitSingularStringField(value: self.fromName, fieldNumber: 4)
    }
    if self.postDate != 0 {
      try visitor.visitSingularUInt64Field(value: self.postDate, fieldNumber: 5)
    }
    if self.lastPostDate != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastPostDate, fieldNumber: 6)
    }
    if self.postNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.postNum, fieldNumber: 7)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 8)
    }
    if !self.userNames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userNames, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShortMessage, rhs: ShortMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.fromID != rhs.fromID {return false}
    if lhs.fromName != rhs.fromName {return false}
    if lhs.postDate != rhs.postDate {return false}
    if lhs.lastPostDate != rhs.lastPostDate {return false}
    if lhs.postNum != rhs.postNum {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.userNames != rhs.userNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShortMessagePost: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ShortMessagePost"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "author_id"),
    3: .same(proto: "subject"),
    4: .same(proto: "content"),
    5: .standard(proto: "post_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authorID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subject) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.postDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.authorID.isEmpty {
      try visitor.visitSingularStringField(value: self.authorID, fieldNumber: 2)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 3)
    }
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.postDate != 0 {
      try visitor.visitSingularUInt64Field(value: self.postDate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShortMessagePost, rhs: ShortMessagePost) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.authorID != rhs.authorID {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs._content != rhs._content {return false}
    if lhs.postDate != rhs.postDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShortMessagePostAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ShortMessagePostAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .same(proto: "mid"),
    3: .standard(proto: "single_to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.singleTo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operation != .reply {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 1)
    }
    if !self.mid.isEmpty {
      try visitor.visitSingularStringField(value: self.mid, fieldNumber: 2)
    }
    if !self.singleTo.isEmpty {
      try visitor.visitSingularStringField(value: self.singleTo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShortMessagePostAction, rhs: ShortMessagePostAction) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.mid != rhs.mid {return false}
    if lhs.singleTo != rhs.singleTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShortMessagePostAction.Operation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REPLY"),
    1: .same(proto: "NEW"),
    2: .same(proto: "NEW_SINGLE_TO"),
  ]
}
