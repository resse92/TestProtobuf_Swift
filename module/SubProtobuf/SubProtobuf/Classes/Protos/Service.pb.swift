// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// Synchronous services that return immediately.
public struct SyncRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: SyncRequest.OneOf_Value? = nil

  /// Configure and initialize logic, should be called once the app is started.
  public var configure: ConfigureRequest {
    get {
      if case .configure(let v)? = value {return v}
      return ConfigureRequest()
    }
    set {value = .configure(newValue)}
  }

  /// Find user info in locally loaded dictionary.
  public var localUser: LocalUserRequest {
    get {
      if case .localUser(let v)? = value {return v}
      return LocalUserRequest()
    }
    set {value = .localUser(newValue)}
  }

  /// Sync auth info to logic, should be called if current user changes.
  public var auth: AuthRequest {
    get {
      if case .auth(let v)? = value {return v}
      return AuthRequest()
    }
    set {value = .auth(newValue)}
  }

  /// Parse string as `PostContent`.
  public var contentParse: ContentParseRequest {
    get {
      if case .contentParse(let v)? = value {return v}
      return ContentParseRequest()
    }
    set {value = .contentParse(newValue)}
  }

  /// Parse string as `Subject` of topic.
  public var subjectParse: SubjectParseRequest {
    get {
      if case .subjectParse(let v)? = value {return v}
      return SubjectParseRequest()
    }
    set {value = .subjectParse(newValue)}
  }

  /// Mark some notifications as read.
  public var markNotiRead: MarkNotificationReadRequest {
    get {
      if case .markNotiRead(let v)? = value {return v}
      return MarkNotificationReadRequest()
    }
    set {value = .markNotiRead(newValue)}
  }

  /// Set options for requesting.
  public var setRequestOption: SetRequestOptionRequest {
    get {
      if case .setRequestOption(let v)? = value {return v}
      return SetRequestOptionRequest()
    }
    set {value = .setRequestOption(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    /// Configure and initialize logic, should be called once the app is started.
    case configure(ConfigureRequest)
    /// Find user info in locally loaded dictionary.
    case localUser(LocalUserRequest)
    /// Sync auth info to logic, should be called if current user changes.
    case auth(AuthRequest)
    /// Parse string as `PostContent`.
    case contentParse(ContentParseRequest)
    /// Parse string as `Subject` of topic.
    case subjectParse(SubjectParseRequest)
    /// Mark some notifications as read.
    case markNotiRead(MarkNotificationReadRequest)
    /// Set options for requesting.
    case setRequestOption(SetRequestOptionRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: SyncRequest.OneOf_Value, rhs: SyncRequest.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.configure, .configure): return {
        guard case .configure(let l) = lhs, case .configure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localUser, .localUser): return {
        guard case .localUser(let l) = lhs, case .localUser(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.auth, .auth): return {
        guard case .auth(let l) = lhs, case .auth(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contentParse, .contentParse): return {
        guard case .contentParse(let l) = lhs, case .contentParse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subjectParse, .subjectParse): return {
        guard case .subjectParse(let l) = lhs, case .subjectParse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.markNotiRead, .markNotiRead): return {
        guard case .markNotiRead(let l) = lhs, case .markNotiRead(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setRequestOption, .setRequestOption): return {
        guard case .setRequestOption(let l) = lhs, case .setRequestOption(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct ConfigureRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var config: Configuration {
    get {return _config ?? Configuration()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  /// Whether this is a debugging environment.
  public var debug: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Configuration? = nil
}

public struct ConfigureResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var error: String {
    get {return _error ?? String()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: String? = nil
}

public struct LocalUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct LocalUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: User {
    get {return _user ?? User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: User? = nil
}

public struct AuthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var info: AuthInfo {
    get {return _info ?? AuthInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: AuthInfo? = nil
}

public struct AuthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ContentParseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var raw: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ContentParseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: PostContent {
    get {return _content ?? PostContent()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {self._content = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _content: PostContent? = nil
}

public struct SubjectParseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var raw: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SubjectParseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subject: Subject {
    get {return _subject ?? Subject()}
    set {_subject = newValue}
  }
  /// Returns true if `subject` has been explicitly set.
  public var hasSubject: Bool {return self._subject != nil}
  /// Clears the value of `subject`. Subsequent reads from it will return its default value.
  public mutating func clearSubject() {self._subject = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _subject: Subject? = nil
}

public struct MarkNotificationReadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MarkNotificationReadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SetRequestOptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var option: RequestOption {
    get {return _option ?? RequestOption()}
    set {_option = newValue}
  }
  /// Returns true if `option` has been explicitly set.
  public var hasOption: Bool {return self._option != nil}
  /// Clears the value of `option`. Subsequent reads from it will return its default value.
  public mutating func clearOption() {self._option = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _option: RequestOption? = nil
}

public struct SetRequestOptionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// Asynchronous services that are called in callback manner.
public struct AsyncRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: AsyncRequest.OneOf_Value? = nil

  /// Get topics in given forum.
  public var topicList: TopicListRequest {
    get {
      if case .topicList(let v)? = value {return v}
      return TopicListRequest()
    }
    set {value = .topicList(newValue)}
  }

  /// Get posts in given topic.
  public var topicDetails: TopicDetailsRequest {
    get {
      if case .topicDetails(let v)? = value {return v}
      return TopicDetailsRequest()
    }
    set {value = .topicDetails(newValue)}
  }

  /// Set filter for subforums.
  public var subforumFilter: SubforumFilterRequest {
    get {
      if case .subforumFilter(let v)? = value {return v}
      return SubforumFilterRequest()
    }
    set {value = .subforumFilter(newValue)}
  }

  /// Get all forums.
  public var forumList: ForumListRequest {
    get {
      if case .forumList(let v)? = value {return v}
      return ForumListRequest()
    }
    set {value = .forumList(newValue)}
  }

  /// Find user info remotely.
  public var remoteUser: RemoteUserRequest {
    get {
      if case .remoteUser(let v)? = value {return v}
      return RemoteUserRequest()
    }
    set {value = .remoteUser(newValue)}
  }

  /// Do voting to posts.
  public var postVote: PostVoteRequest {
    get {
      if case .postVote(let v)? = value {return v}
      return PostVoteRequest()
    }
    set {value = .postVote(newValue)}
  }

  /// Get history of visited topics.
  public var topicHistory: TopicHistoryRequest {
    get {
      if case .topicHistory(let v)? = value {return v}
      return TopicHistoryRequest()
    }
    set {value = .topicHistory(newValue)}
  }

  /// Get hot topics in given forum.
  public var hotTopicList: HotTopicListRequest {
    get {
      if case .hotTopicList(let v)? = value {return v}
      return HotTopicListRequest()
    }
    set {value = .hotTopicList(newValue)}
  }

  /// Search for a specific forum.
  public var forumSearch: ForumSearchRequest {
    get {
      if case .forumSearch(let v)? = value {return v}
      return ForumSearchRequest()
    }
    set {value = .forumSearch(newValue)}
  }

  /// Get favorite topics.
  public var favoriteTopicList: FavoriteTopicListRequest {
    get {
      if case .favoriteTopicList(let v)? = value {return v}
      return FavoriteTopicListRequest()
    }
    set {value = .favoriteTopicList(newValue)}
  }

  /// Mark a topic as favored.
  public var topicFavor: TopicFavorRequest {
    get {
      if case .topicFavor(let v)? = value {return v}
      return TopicFavorRequest()
    }
    set {value = .topicFavor(newValue)}
  }

  /// Fetch the initial content for a posting action.
  public var postReplyFetchContent: PostReplyFetchContentRequest {
    get {
      if case .postReplyFetchContent(let v)? = value {return v}
      return PostReplyFetchContentRequest()
    }
    set {value = .postReplyFetchContent(newValue)}
  }

  /// Do posting to some topic or forum.
  public var postReply: PostReplyRequest {
    get {
      if case .postReply(let v)? = value {return v}
      return PostReplyRequest()
    }
    set {value = .postReply(newValue)}
  }

  /// Get all notifications.
  public var fetchNotification: FetchNotificationRequest {
    get {
      if case .fetchNotification(let v)? = value {return v}
      return FetchNotificationRequest()
    }
    set {value = .fetchNotification(newValue)}
  }

  /// Upload attachments before posting.
  public var uploadAttachment: UploadAttachmentRequest {
    get {
      if case .uploadAttachment(let v)? = value {return v}
      return UploadAttachmentRequest()
    }
    set {value = .uploadAttachment(newValue)}
  }

  /// Get topics of given user.
  public var userTopicList: UserTopicListRequest {
    get {
      if case .userTopicList(let v)? = value {return v}
      return UserTopicListRequest()
    }
    set {value = .userTopicList(newValue)}
  }

  /// Get posts of given user.
  public var userPostList: UserPostListRequest {
    get {
      if case .userPostList(let v)? = value {return v}
      return UserPostListRequest()
    }
    set {value = .userPostList(newValue)}
  }

  /// Get short message conversations of current user.
  public var shortMessageList: ShortMessageListRequest {
    get {
      if case .shortMessageList(let v)? = value {return v}
      return ShortMessageListRequest()
    }
    set {value = .shortMessageList(newValue)}
  }

  /// Get short message posts of a conversation.
  public var shortMessageDetails: ShortMessageDetailsRequest {
    get {
      if case .shortMessageDetails(let v)? = value {return v}
      return ShortMessageDetailsRequest()
    }
    set {value = .shortMessageDetails(newValue)}
  }

  /// Do posting to some short message post or conversation.
  public var shortMessagePost: ShortMessagePostRequest {
    get {
      if case .shortMessagePost(let v)? = value {return v}
      return ShortMessagePostRequest()
    }
    set {value = .shortMessagePost(newValue)}
  }

  /// Search for topics with some keyword in specific forum or all forums.
  public var topicSearch: TopicSearchRequest {
    get {
      if case .topicSearch(let v)? = value {return v}
      return TopicSearchRequest()
    }
    set {value = .topicSearch(newValue)}
  }

  /// Sign in (clock in) for today.
  public var clockIn: ClockInRequest {
    get {
      if case .clockIn(let v)? = value {return v}
      return ClockInRequest()
    }
    set {value = .clockIn(newValue)}
  }

  /// Clear or check the cache.
  public var cache: CacheRequest {
    get {
      if case .cache(let v)? = value {return v}
      return CacheRequest()
    }
    set {value = .cache(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    /// Get topics in given forum.
    case topicList(TopicListRequest)
    /// Get posts in given topic.
    case topicDetails(TopicDetailsRequest)
    /// Set filter for subforums.
    case subforumFilter(SubforumFilterRequest)
    /// Get all forums.
    case forumList(ForumListRequest)
    /// Find user info remotely.
    case remoteUser(RemoteUserRequest)
    /// Do voting to posts.
    case postVote(PostVoteRequest)
    /// Get history of visited topics.
    case topicHistory(TopicHistoryRequest)
    /// Get hot topics in given forum.
    case hotTopicList(HotTopicListRequest)
    /// Search for a specific forum.
    case forumSearch(ForumSearchRequest)
    /// Get favorite topics.
    case favoriteTopicList(FavoriteTopicListRequest)
    /// Mark a topic as favored.
    case topicFavor(TopicFavorRequest)
    /// Fetch the initial content for a posting action.
    case postReplyFetchContent(PostReplyFetchContentRequest)
    /// Do posting to some topic or forum.
    case postReply(PostReplyRequest)
    /// Get all notifications.
    case fetchNotification(FetchNotificationRequest)
    /// Upload attachments before posting.
    case uploadAttachment(UploadAttachmentRequest)
    /// Get topics of given user.
    case userTopicList(UserTopicListRequest)
    /// Get posts of given user.
    case userPostList(UserPostListRequest)
    /// Get short message conversations of current user.
    case shortMessageList(ShortMessageListRequest)
    /// Get short message posts of a conversation.
    case shortMessageDetails(ShortMessageDetailsRequest)
    /// Do posting to some short message post or conversation.
    case shortMessagePost(ShortMessagePostRequest)
    /// Search for topics with some keyword in specific forum or all forums.
    case topicSearch(TopicSearchRequest)
    /// Sign in (clock in) for today.
    case clockIn(ClockInRequest)
    /// Clear or check the cache.
    case cache(CacheRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: AsyncRequest.OneOf_Value, rhs: AsyncRequest.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.topicList, .topicList): return {
        guard case .topicList(let l) = lhs, case .topicList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.topicDetails, .topicDetails): return {
        guard case .topicDetails(let l) = lhs, case .topicDetails(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subforumFilter, .subforumFilter): return {
        guard case .subforumFilter(let l) = lhs, case .subforumFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.forumList, .forumList): return {
        guard case .forumList(let l) = lhs, case .forumList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.remoteUser, .remoteUser): return {
        guard case .remoteUser(let l) = lhs, case .remoteUser(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postVote, .postVote): return {
        guard case .postVote(let l) = lhs, case .postVote(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.topicHistory, .topicHistory): return {
        guard case .topicHistory(let l) = lhs, case .topicHistory(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hotTopicList, .hotTopicList): return {
        guard case .hotTopicList(let l) = lhs, case .hotTopicList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.forumSearch, .forumSearch): return {
        guard case .forumSearch(let l) = lhs, case .forumSearch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.favoriteTopicList, .favoriteTopicList): return {
        guard case .favoriteTopicList(let l) = lhs, case .favoriteTopicList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.topicFavor, .topicFavor): return {
        guard case .topicFavor(let l) = lhs, case .topicFavor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postReplyFetchContent, .postReplyFetchContent): return {
        guard case .postReplyFetchContent(let l) = lhs, case .postReplyFetchContent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postReply, .postReply): return {
        guard case .postReply(let l) = lhs, case .postReply(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fetchNotification, .fetchNotification): return {
        guard case .fetchNotification(let l) = lhs, case .fetchNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uploadAttachment, .uploadAttachment): return {
        guard case .uploadAttachment(let l) = lhs, case .uploadAttachment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userTopicList, .userTopicList): return {
        guard case .userTopicList(let l) = lhs, case .userTopicList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userPostList, .userPostList): return {
        guard case .userPostList(let l) = lhs, case .userPostList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.shortMessageList, .shortMessageList): return {
        guard case .shortMessageList(let l) = lhs, case .shortMessageList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.shortMessageDetails, .shortMessageDetails): return {
        guard case .shortMessageDetails(let l) = lhs, case .shortMessageDetails(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.shortMessagePost, .shortMessagePost): return {
        guard case .shortMessagePost(let l) = lhs, case .shortMessagePost(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.topicSearch, .topicSearch): return {
        guard case .topicSearch(let l) = lhs, case .topicSearch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clockIn, .clockIn): return {
        guard case .clockIn(let l) = lhs, case .clockIn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cache, .cache): return {
        guard case .cache(let l) = lhs, case .cache(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct TopicListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: ForumId {
    get {return _id ?? ForumId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var page: UInt32 = 0

  public var sortSubforums: Bool = false

  public var order: TopicListRequest.Order = .lastPost

  /// Whether to only show recommended topics.
  public var recommendedOnly: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Order: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Order by the time of the last post of the topic.
    case lastPost // = 0

    /// Order by the initial post time of the topic.
    case postDate // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .lastPost
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .lastPost
      case 1: self = .postDate
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .lastPost: return 0
      case .postDate: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _id: ForumId? = nil
}

#if swift(>=4.2)

extension TopicListRequest.Order: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TopicListRequest.Order] = [
    .lastPost,
    .postDate,
  ]
}

#endif  // swift(>=4.2)

public struct TopicListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Details of the given forum id.
  public var forum: Forum {
    get {return _forum ?? Forum()}
    set {_forum = newValue}
  }
  /// Returns true if `forum` has been explicitly set.
  public var hasForum: Bool {return self._forum != nil}
  /// Clears the value of `forum`. Subsequent reads from it will return its default value.
  public mutating func clearForum() {self._forum = nil}

  public var topics: [Topic] = []

  public var pages: UInt32 = 0

  public var subforums: [Subforum] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _forum: Forum? = nil
}

public struct TopicDetailsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topicID: String = String()

  /// See `Topic.fav`
  public var fav: String = String()

  public var postID: String = String()

  public var authorID: String = String()

  public var page: UInt32 = 0

  /// Whether to only request cached version of the topic.
  public var localCache: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TopicDetailsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: Topic {
    get {return _topic ?? Topic()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  public var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  public mutating func clearTopic() {self._topic = nil}

  public var replies: [Post] = []

  public var forumName: String = String()

  public var pages: UInt32 = 0

  /// Whether the replies are from local cache.
  public var isLocalCache: Bool = false

  public var inPlaceUsers: [User] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _topic: Topic? = nil
}

public struct SubforumFilterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var operation: SubforumFilterRequest.Operation = .show

  /// ID of the parent forum.
  public var forumID: String = String()

  /// See `Subforum.filter_id`
  public var subforumFilterID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Operation: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Subscribe.
    case show // = 0

    /// Unsubscribe.
    case block // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .show
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .show
      case 1: self = .block
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .show: return 0
      case .block: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension SubforumFilterRequest.Operation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SubforumFilterRequest.Operation] = [
    .show,
    .block,
  ]
}

#endif  // swift(>=4.2)

public struct SubforumFilterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForumListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForumListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var categories: [Category] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RemoteUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request by ID.
  public var userID: String = String()

  /// Request by name.
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RemoteUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: User {
    get {return _user ?? User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: User? = nil
}

public struct PostVoteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var operation: PostVoteRequest.Operation = .upvote

  public var postID: PostId {
    get {return _postID ?? PostId()}
    set {_postID = newValue}
  }
  /// Returns true if `postID` has been explicitly set.
  public var hasPostID: Bool {return self._postID != nil}
  /// Clears the value of `postID`. Subsequent reads from it will return its default value.
  public mutating func clearPostID() {self._postID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Operation: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case upvote // = 0
    case downvote // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .upvote
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .upvote
      case 1: self = .downvote
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .upvote: return 0
      case .downvote: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _postID: PostId? = nil
}

#if swift(>=4.2)

extension PostVoteRequest.Operation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PostVoteRequest.Operation] = [
    .upvote,
    .downvote,
  ]
}

#endif  // swift(>=4.2)

public struct PostVoteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Delta to add to the current score.
  public var delta: Int32 = 0

  /// not used
  public var error: String {
    get {return _error ?? String()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  /// Vote state after voting.
  public var state: VoteState = .none

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: String? = nil
}

public struct TopicHistoryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var limit: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TopicHistoryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topics: [TopicSnapshot] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct HotTopicListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: ForumId {
    get {return _id ?? ForumId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// Only see topics posted in this date range.
  public var range: HotTopicListRequest.DateRange = .day

  /// Maximum page of topics to collect.
  public var fetchPageLimit: UInt32 {
    get {return _fetchPageLimit ?? 0}
    set {_fetchPageLimit = newValue}
  }
  /// Returns true if `fetchPageLimit` has been explicitly set.
  public var hasFetchPageLimit: Bool {return self._fetchPageLimit != nil}
  /// Clears the value of `fetchPageLimit`. Subsequent reads from it will return its default value.
  public mutating func clearFetchPageLimit() {self._fetchPageLimit = nil}

  public var limit: UInt64 {
    get {return _limit ?? 0}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum DateRange: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case day // = 0
    case week // = 1
    case month // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .day
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .day
      case 1: self = .week
      case 2: self = .month
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .day: return 0
      case .week: return 1
      case .month: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _id: ForumId? = nil
  fileprivate var _fetchPageLimit: UInt32? = nil
  fileprivate var _limit: UInt64? = nil
}

#if swift(>=4.2)

extension HotTopicListRequest.DateRange: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [HotTopicListRequest.DateRange] = [
    .day,
    .week,
    .month,
  ]
}

#endif  // swift(>=4.2)

public struct HotTopicListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topics: [Topic] = []

  /// Details of the given forum id.
  public var forum: Forum {
    get {return _forum ?? Forum()}
    set {_forum = newValue}
  }
  /// Returns true if `forum` has been explicitly set.
  public var hasForum: Bool {return self._forum != nil}
  /// Clears the value of `forum`. Subsequent reads from it will return its default value.
  public mutating func clearForum() {self._forum = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _forum: Forum? = nil
}

public struct ForumSearchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForumSearchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var forums: [Forum] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FavoriteTopicListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var page: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FavoriteTopicListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topics: [Topic] = []

  public var pages: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TopicFavorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topicID: String = String()

  public var operation: TopicFavorRequest.Operation = .add

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Operation: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case add // = 0
    case delete // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .add
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .add
      case 1: self = .delete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .add: return 0
      case .delete: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension TopicFavorRequest.Operation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TopicFavorRequest.Operation] = [
    .add,
    .delete,
  ]
}

#endif  // swift(>=4.2)

public struct TopicFavorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isFavored: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PostReplyFetchContentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: PostReplyAction {
    get {return _action ?? PostReplyAction()}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _action: PostReplyAction? = nil
}

public struct PostReplyFetchContentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: String = String()

  /// Used for topics.
  public var subject: String {
    get {return _subject ?? String()}
    set {_subject = newValue}
  }
  /// Returns true if `subject` has been explicitly set.
  public var hasSubject: Bool {return self._subject != nil}
  /// Clears the value of `subject`. Subsequent reads from it will return its default value.
  public mutating func clearSubject() {self._subject = nil}

  /// Extra info to keep and pass verbatim.
  public var verbatim: PostReplyVerbatim {
    get {return _verbatim ?? PostReplyVerbatim()}
    set {_verbatim = newValue}
  }
  /// Returns true if `verbatim` has been explicitly set.
  public var hasVerbatim: Bool {return self._verbatim != nil}
  /// Clears the value of `verbatim`. Subsequent reads from it will return its default value.
  public mutating func clearVerbatim() {self._verbatim = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _subject: String? = nil
  fileprivate var _verbatim: PostReplyVerbatim? = nil
}

public struct PostReplyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: PostReplyAction {
    get {return _action ?? PostReplyAction()}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  public var content: String = String()

  public var subject: String {
    get {return _subject ?? String()}
    set {_subject = newValue}
  }
  /// Returns true if `subject` has been explicitly set.
  public var hasSubject: Bool {return self._subject != nil}
  /// Clears the value of `subject`. Subsequent reads from it will return its default value.
  public mutating func clearSubject() {self._subject = nil}

  public var attachments: [PostAttachment] = []

  /// Whether to post as anonymous identity.
  public var anonymous: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _action: PostReplyAction? = nil
  fileprivate var _subject: String? = nil
}

public struct PostReplyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FetchNotificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FetchNotificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var notis: [Notification] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UploadAttachmentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: PostReplyAction {
    get {return _action ?? PostReplyAction()}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  /// Data of the file.
  public var file: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _action: PostReplyAction? = nil
}

public struct UploadAttachmentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var attachment: PostAttachment {
    get {return _attachment ?? PostAttachment()}
    set {_attachment = newValue}
  }
  /// Returns true if `attachment` has been explicitly set.
  public var hasAttachment: Bool {return self._attachment != nil}
  /// Clears the value of `attachment`. Subsequent reads from it will return its default value.
  public mutating func clearAttachment() {self._attachment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _attachment: PostAttachment? = nil
}

public struct UserTopicListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var authorID: String = String()

  public var page: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UserTopicListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topics: [Topic] = []

  public var pages: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UserPostListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var authorID: String = String()

  public var page: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UserPostListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tps: [TopicWithLightPost] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ShortMessageListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var page: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ShortMessageListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [ShortMessage] = []

  public var pages: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ShortMessageDetailsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var page: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ShortMessageDetailsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var posts: [ShortMessagePost] = []

  public var pages: UInt32 = 0

  public var ids: [String] = []

  public var userNames: [UserName] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ShortMessagePostRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: ShortMessagePostAction {
    get {return _action ?? ShortMessagePostAction()}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  public var content: String = String()

  public var subject: String = String()

  /// Used if `action.operation`` is `NEW`
  public var to: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _action: ShortMessagePostAction? = nil
}

public struct ShortMessagePostResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TopicSearchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If not provided, search in all forums.
  public var id: ForumId {
    get {return _id ?? ForumId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var page: UInt32 = 0

  /// Whether to search content for the key.
  public var searchContent: Bool = false

  /// Whether to only search recommended topics.
  public var recommendedOnly: Bool = false

  public var key: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: ForumId? = nil
}

public struct TopicSearchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topics: [Topic] = []

  public var pages: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ClockInRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ClockInResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: String = String()

  public var isFirstTime: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: CacheType = .all

  public var operation: CacheOperation = .check

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var items: UInt64 = 0

  public var totalSize: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// MNGA-only mock APIs.
public struct MockApi {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: MockApi.OneOf_Value? = nil

  public var topicList: MockApi.TopicList {
    get {
      if case .topicList(let v)? = value {return v}
      return MockApi.TopicList()
    }
    set {value = .topicList(newValue)}
  }

  public var topicDetails: MockApi.TopicDetails {
    get {
      if case .topicDetails(let v)? = value {return v}
      return MockApi.TopicDetails()
    }
    set {value = .topicDetails(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case topicList(MockApi.TopicList)
    case topicDetails(MockApi.TopicDetails)

  #if !swift(>=4.1)
    public static func ==(lhs: MockApi.OneOf_Value, rhs: MockApi.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.topicList, .topicList): return {
        guard case .topicList(let l) = lhs, case .topicList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.topicDetails, .topicDetails): return {
        guard case .topicDetails(let l) = lhs, case .topicDetails(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct TopicList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TopicDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension SyncRequest: @unchecked Sendable {}
extension SyncRequest.OneOf_Value: @unchecked Sendable {}
extension ConfigureRequest: @unchecked Sendable {}
extension ConfigureResponse: @unchecked Sendable {}
extension LocalUserRequest: @unchecked Sendable {}
extension LocalUserResponse: @unchecked Sendable {}
extension AuthRequest: @unchecked Sendable {}
extension AuthResponse: @unchecked Sendable {}
extension ContentParseRequest: @unchecked Sendable {}
extension ContentParseResponse: @unchecked Sendable {}
extension SubjectParseRequest: @unchecked Sendable {}
extension SubjectParseResponse: @unchecked Sendable {}
extension MarkNotificationReadRequest: @unchecked Sendable {}
extension MarkNotificationReadResponse: @unchecked Sendable {}
extension SetRequestOptionRequest: @unchecked Sendable {}
extension SetRequestOptionResponse: @unchecked Sendable {}
extension AsyncRequest: @unchecked Sendable {}
extension AsyncRequest.OneOf_Value: @unchecked Sendable {}
extension TopicListRequest: @unchecked Sendable {}
extension TopicListRequest.Order: @unchecked Sendable {}
extension TopicListResponse: @unchecked Sendable {}
extension TopicDetailsRequest: @unchecked Sendable {}
extension TopicDetailsResponse: @unchecked Sendable {}
extension SubforumFilterRequest: @unchecked Sendable {}
extension SubforumFilterRequest.Operation: @unchecked Sendable {}
extension SubforumFilterResponse: @unchecked Sendable {}
extension ForumListRequest: @unchecked Sendable {}
extension ForumListResponse: @unchecked Sendable {}
extension RemoteUserRequest: @unchecked Sendable {}
extension RemoteUserResponse: @unchecked Sendable {}
extension PostVoteRequest: @unchecked Sendable {}
extension PostVoteRequest.Operation: @unchecked Sendable {}
extension PostVoteResponse: @unchecked Sendable {}
extension TopicHistoryRequest: @unchecked Sendable {}
extension TopicHistoryResponse: @unchecked Sendable {}
extension HotTopicListRequest: @unchecked Sendable {}
extension HotTopicListRequest.DateRange: @unchecked Sendable {}
extension HotTopicListResponse: @unchecked Sendable {}
extension ForumSearchRequest: @unchecked Sendable {}
extension ForumSearchResponse: @unchecked Sendable {}
extension FavoriteTopicListRequest: @unchecked Sendable {}
extension FavoriteTopicListResponse: @unchecked Sendable {}
extension TopicFavorRequest: @unchecked Sendable {}
extension TopicFavorRequest.Operation: @unchecked Sendable {}
extension TopicFavorResponse: @unchecked Sendable {}
extension PostReplyFetchContentRequest: @unchecked Sendable {}
extension PostReplyFetchContentResponse: @unchecked Sendable {}
extension PostReplyRequest: @unchecked Sendable {}
extension PostReplyResponse: @unchecked Sendable {}
extension FetchNotificationRequest: @unchecked Sendable {}
extension FetchNotificationResponse: @unchecked Sendable {}
extension UploadAttachmentRequest: @unchecked Sendable {}
extension UploadAttachmentResponse: @unchecked Sendable {}
extension UserTopicListRequest: @unchecked Sendable {}
extension UserTopicListResponse: @unchecked Sendable {}
extension UserPostListRequest: @unchecked Sendable {}
extension UserPostListResponse: @unchecked Sendable {}
extension ShortMessageListRequest: @unchecked Sendable {}
extension ShortMessageListResponse: @unchecked Sendable {}
extension ShortMessageDetailsRequest: @unchecked Sendable {}
extension ShortMessageDetailsResponse: @unchecked Sendable {}
extension ShortMessagePostRequest: @unchecked Sendable {}
extension ShortMessagePostResponse: @unchecked Sendable {}
extension TopicSearchRequest: @unchecked Sendable {}
extension TopicSearchResponse: @unchecked Sendable {}
extension ClockInRequest: @unchecked Sendable {}
extension ClockInResponse: @unchecked Sendable {}
extension CacheRequest: @unchecked Sendable {}
extension CacheResponse: @unchecked Sendable {}
extension MockApi: @unchecked Sendable {}
extension MockApi.OneOf_Value: @unchecked Sendable {}
extension MockApi.TopicList: @unchecked Sendable {}
extension MockApi.TopicDetails: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension SyncRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SyncRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "configure"),
    2: .standard(proto: "local_user"),
    3: .same(proto: "auth"),
    4: .standard(proto: "content_parse"),
    5: .standard(proto: "subject_parse"),
    6: .standard(proto: "mark_noti_read"),
    7: .standard(proto: "set_request_option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: ConfigureRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .configure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .configure(v)
        }
      }()
      case 2: try {
        var v: LocalUserRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .localUser(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .localUser(v)
        }
      }()
      case 3: try {
        var v: AuthRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .auth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .auth(v)
        }
      }()
      case 4: try {
        var v: ContentParseRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .contentParse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .contentParse(v)
        }
      }()
      case 5: try {
        var v: SubjectParseRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .subjectParse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .subjectParse(v)
        }
      }()
      case 6: try {
        var v: MarkNotificationReadRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .markNotiRead(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .markNotiRead(v)
        }
      }()
      case 7: try {
        var v: SetRequestOptionRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .setRequestOption(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .setRequestOption(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .configure?: try {
      guard case .configure(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .localUser?: try {
      guard case .localUser(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .auth?: try {
      guard case .auth(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .contentParse?: try {
      guard case .contentParse(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .subjectParse?: try {
      guard case .subjectParse(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .markNotiRead?: try {
      guard case .markNotiRead(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .setRequestOption?: try {
      guard case .setRequestOption(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SyncRequest, rhs: SyncRequest) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConfigureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ConfigureRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .same(proto: "debug"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.debug) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.debug != false {
      try visitor.visitSingularBoolField(value: self.debug, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConfigureRequest, rhs: ConfigureRequest) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.debug != rhs.debug {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConfigureResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ConfigureResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConfigureResponse, rhs: ConfigureResponse) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LocalUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LocalUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LocalUserRequest, rhs: LocalUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LocalUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LocalUserResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LocalUserResponse, rhs: LocalUserResponse) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AuthRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AuthRequest, rhs: AuthRequest) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AuthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AuthResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AuthResponse, rhs: AuthResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ContentParseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ContentParseRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "raw"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.raw) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.raw.isEmpty {
      try visitor.visitSingularStringField(value: self.raw, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ContentParseRequest, rhs: ContentParseRequest) -> Bool {
    if lhs.raw != rhs.raw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ContentParseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ContentParseResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ContentParseResponse, rhs: ContentParseResponse) -> Bool {
    if lhs._content != rhs._content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubjectParseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SubjectParseRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "raw"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.raw) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.raw.isEmpty {
      try visitor.visitSingularStringField(value: self.raw, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubjectParseRequest, rhs: SubjectParseRequest) -> Bool {
    if lhs.raw != rhs.raw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubjectParseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SubjectParseResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subject"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subject) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._subject {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubjectParseResponse, rhs: SubjectParseResponse) -> Bool {
    if lhs._subject != rhs._subject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MarkNotificationReadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MarkNotificationReadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MarkNotificationReadRequest, rhs: MarkNotificationReadRequest) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MarkNotificationReadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MarkNotificationReadResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MarkNotificationReadResponse, rhs: MarkNotificationReadResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SetRequestOptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SetRequestOptionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._option) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._option {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SetRequestOptionRequest, rhs: SetRequestOptionRequest) -> Bool {
    if lhs._option != rhs._option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SetRequestOptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SetRequestOptionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SetRequestOptionResponse, rhs: SetRequestOptionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AsyncRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AsyncRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "topic_list"),
    2: .standard(proto: "topic_details"),
    3: .standard(proto: "subforum_filter"),
    4: .standard(proto: "forum_list"),
    5: .standard(proto: "remote_user"),
    6: .standard(proto: "post_vote"),
    7: .standard(proto: "topic_history"),
    8: .standard(proto: "hot_topic_list"),
    9: .standard(proto: "forum_search"),
    10: .standard(proto: "favorite_topic_list"),
    11: .standard(proto: "topic_favor"),
    12: .standard(proto: "post_reply_fetch_content"),
    13: .standard(proto: "post_reply"),
    14: .standard(proto: "fetch_notification"),
    15: .standard(proto: "upload_attachment"),
    16: .standard(proto: "user_topic_list"),
    17: .standard(proto: "user_post_list"),
    18: .standard(proto: "short_message_list"),
    19: .standard(proto: "short_message_details"),
    20: .standard(proto: "short_message_post"),
    21: .standard(proto: "topic_search"),
    22: .standard(proto: "clock_in"),
    23: .same(proto: "cache"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: TopicListRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .topicList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .topicList(v)
        }
      }()
      case 2: try {
        var v: TopicDetailsRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .topicDetails(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .topicDetails(v)
        }
      }()
      case 3: try {
        var v: SubforumFilterRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .subforumFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .subforumFilter(v)
        }
      }()
      case 4: try {
        var v: ForumListRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .forumList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .forumList(v)
        }
      }()
      case 5: try {
        var v: RemoteUserRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .remoteUser(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .remoteUser(v)
        }
      }()
      case 6: try {
        var v: PostVoteRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .postVote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .postVote(v)
        }
      }()
      case 7: try {
        var v: TopicHistoryRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .topicHistory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .topicHistory(v)
        }
      }()
      case 8: try {
        var v: HotTopicListRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .hotTopicList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .hotTopicList(v)
        }
      }()
      case 9: try {
        var v: ForumSearchRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .forumSearch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .forumSearch(v)
        }
      }()
      case 10: try {
        var v: FavoriteTopicListRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .favoriteTopicList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .favoriteTopicList(v)
        }
      }()
      case 11: try {
        var v: TopicFavorRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .topicFavor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .topicFavor(v)
        }
      }()
      case 12: try {
        var v: PostReplyFetchContentRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .postReplyFetchContent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .postReplyFetchContent(v)
        }
      }()
      case 13: try {
        var v: PostReplyRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .postReply(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .postReply(v)
        }
      }()
      case 14: try {
        var v: FetchNotificationRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .fetchNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .fetchNotification(v)
        }
      }()
      case 15: try {
        var v: UploadAttachmentRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .uploadAttachment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .uploadAttachment(v)
        }
      }()
      case 16: try {
        var v: UserTopicListRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .userTopicList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .userTopicList(v)
        }
      }()
      case 17: try {
        var v: UserPostListRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .userPostList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .userPostList(v)
        }
      }()
      case 18: try {
        var v: ShortMessageListRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .shortMessageList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .shortMessageList(v)
        }
      }()
      case 19: try {
        var v: ShortMessageDetailsRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .shortMessageDetails(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .shortMessageDetails(v)
        }
      }()
      case 20: try {
        var v: ShortMessagePostRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .shortMessagePost(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .shortMessagePost(v)
        }
      }()
      case 21: try {
        var v: TopicSearchRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .topicSearch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .topicSearch(v)
        }
      }()
      case 22: try {
        var v: ClockInRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .clockIn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .clockIn(v)
        }
      }()
      case 23: try {
        var v: CacheRequest?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .cache(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .cache(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .topicList?: try {
      guard case .topicList(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .topicDetails?: try {
      guard case .topicDetails(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subforumFilter?: try {
      guard case .subforumFilter(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .forumList?: try {
      guard case .forumList(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .remoteUser?: try {
      guard case .remoteUser(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .postVote?: try {
      guard case .postVote(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .topicHistory?: try {
      guard case .topicHistory(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .hotTopicList?: try {
      guard case .hotTopicList(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .forumSearch?: try {
      guard case .forumSearch(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .favoriteTopicList?: try {
      guard case .favoriteTopicList(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .topicFavor?: try {
      guard case .topicFavor(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .postReplyFetchContent?: try {
      guard case .postReplyFetchContent(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .postReply?: try {
      guard case .postReply(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .fetchNotification?: try {
      guard case .fetchNotification(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .uploadAttachment?: try {
      guard case .uploadAttachment(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .userTopicList?: try {
      guard case .userTopicList(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .userPostList?: try {
      guard case .userPostList(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .shortMessageList?: try {
      guard case .shortMessageList(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .shortMessageDetails?: try {
      guard case .shortMessageDetails(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .shortMessagePost?: try {
      guard case .shortMessagePost(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .topicSearch?: try {
      guard case .topicSearch(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .clockIn?: try {
      guard case .clockIn(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .cache?: try {
      guard case .cache(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AsyncRequest, rhs: AsyncRequest) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TopicListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TopicListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "page"),
    4: .standard(proto: "sort_subforums"),
    5: .same(proto: "order"),
    6: .standard(proto: "recommended_only"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.sortSubforums) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.order) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.recommendedOnly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.sortSubforums != false {
      try visitor.visitSingularBoolField(value: self.sortSubforums, fieldNumber: 4)
    }
    if self.order != .lastPost {
      try visitor.visitSingularEnumField(value: self.order, fieldNumber: 5)
    }
    if self.recommendedOnly != false {
      try visitor.visitSingularBoolField(value: self.recommendedOnly, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TopicListRequest, rhs: TopicListRequest) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.page != rhs.page {return false}
    if lhs.sortSubforums != rhs.sortSubforums {return false}
    if lhs.order != rhs.order {return false}
    if lhs.recommendedOnly != rhs.recommendedOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TopicListRequest.Order: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LAST_POST"),
    1: .same(proto: "POST_DATE"),
  ]
}

extension TopicListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TopicListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "forum"),
    1: .same(proto: "topics"),
    2: .same(proto: "pages"),
    3: .same(proto: "subforums"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.topics) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pages) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.subforums) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._forum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.topics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topics, fieldNumber: 1)
    }
    if self.pages != 0 {
      try visitor.visitSingularUInt32Field(value: self.pages, fieldNumber: 2)
    }
    if !self.subforums.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subforums, fieldNumber: 3)
    }
    try { if let v = self._forum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TopicListResponse, rhs: TopicListResponse) -> Bool {
    if lhs._forum != rhs._forum {return false}
    if lhs.topics != rhs.topics {return false}
    if lhs.pages != rhs.pages {return false}
    if lhs.subforums != rhs.subforums {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TopicDetailsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TopicDetailsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "topic_id"),
    3: .same(proto: "fav"),
    4: .standard(proto: "post_id"),
    5: .standard(proto: "author_id"),
    2: .same(proto: "page"),
    6: .standard(proto: "local_cache"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topicID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fav) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.postID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.authorID) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.localCache) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topicID.isEmpty {
      try visitor.visitSingularStringField(value: self.topicID, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if !self.fav.isEmpty {
      try visitor.visitSingularStringField(value: self.fav, fieldNumber: 3)
    }
    if !self.postID.isEmpty {
      try visitor.visitSingularStringField(value: self.postID, fieldNumber: 4)
    }
    if !self.authorID.isEmpty {
      try visitor.visitSingularStringField(value: self.authorID, fieldNumber: 5)
    }
    if self.localCache != false {
      try visitor.visitSingularBoolField(value: self.localCache, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TopicDetailsRequest, rhs: TopicDetailsRequest) -> Bool {
    if lhs.topicID != rhs.topicID {return false}
    if lhs.fav != rhs.fav {return false}
    if lhs.postID != rhs.postID {return false}
    if lhs.authorID != rhs.authorID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.localCache != rhs.localCache {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TopicDetailsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TopicDetailsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "replies"),
    4: .standard(proto: "forum_name"),
    3: .same(proto: "pages"),
    5: .standard(proto: "is_local_cache"),
    6: .standard(proto: "in_place_users"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._topic) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.replies) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.pages) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.forumName) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isLocalCache) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.inPlaceUsers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.replies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.replies, fieldNumber: 2)
    }
    if self.pages != 0 {
      try visitor.visitSingularUInt32Field(value: self.pages, fieldNumber: 3)
    }
    if !self.forumName.isEmpty {
      try visitor.visitSingularStringField(value: self.forumName, fieldNumber: 4)
    }
    if self.isLocalCache != false {
      try visitor.visitSingularBoolField(value: self.isLocalCache, fieldNumber: 5)
    }
    if !self.inPlaceUsers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inPlaceUsers, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TopicDetailsResponse, rhs: TopicDetailsResponse) -> Bool {
    if lhs._topic != rhs._topic {return false}
    if lhs.replies != rhs.replies {return false}
    if lhs.forumName != rhs.forumName {return false}
    if lhs.pages != rhs.pages {return false}
    if lhs.isLocalCache != rhs.isLocalCache {return false}
    if lhs.inPlaceUsers != rhs.inPlaceUsers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubforumFilterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SubforumFilterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .standard(proto: "forum_id"),
    3: .standard(proto: "subforum_filter_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.forumID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subforumFilterID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operation != .show {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 1)
    }
    if !self.forumID.isEmpty {
      try visitor.visitSingularStringField(value: self.forumID, fieldNumber: 2)
    }
    if !self.subforumFilterID.isEmpty {
      try visitor.visitSingularStringField(value: self.subforumFilterID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubforumFilterRequest, rhs: SubforumFilterRequest) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.forumID != rhs.forumID {return false}
    if lhs.subforumFilterID != rhs.subforumFilterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubforumFilterRequest.Operation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHOW"),
    1: .same(proto: "BLOCK"),
  ]
}

extension SubforumFilterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SubforumFilterResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SubforumFilterResponse, rhs: SubforumFilterResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForumListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ForumListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForumListRequest, rhs: ForumListRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForumListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ForumListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "categories"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.categories) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.categories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.categories, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForumListResponse, rhs: ForumListResponse) -> Bool {
    if lhs.categories != rhs.categories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RemoteUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RemoteUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RemoteUserRequest, rhs: RemoteUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RemoteUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RemoteUserResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RemoteUserResponse, rhs: RemoteUserResponse) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PostVoteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PostVoteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .standard(proto: "post_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._postID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operation != .upvote {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 1)
    }
    try { if let v = self._postID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PostVoteRequest, rhs: PostVoteRequest) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs._postID != rhs._postID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PostVoteRequest.Operation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPVOTE"),
    1: .same(proto: "DOWNVOTE"),
  ]
}

extension PostVoteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PostVoteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delta"),
    2: .same(proto: "error"),
    3: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSInt32Field(value: &self.delta) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._error) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.delta != 0 {
      try visitor.visitSingularSInt32Field(value: self.delta, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.state != .none {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PostVoteResponse, rhs: PostVoteResponse) -> Bool {
    if lhs.delta != rhs.delta {return false}
    if lhs._error != rhs._error {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TopicHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TopicHistoryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.limit != 0 {
      try visitor.visitSingularUInt64Field(value: self.limit, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TopicHistoryRequest, rhs: TopicHistoryRequest) -> Bool {
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TopicHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TopicHistoryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.topics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TopicHistoryResponse, rhs: TopicHistoryResponse) -> Bool {
    if lhs.topics != rhs.topics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HotTopicListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "HotTopicListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "range"),
    3: .standard(proto: "fetch_page_limit"),
    4: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.range) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._fetchPageLimit) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.range != .day {
      try visitor.visitSingularEnumField(value: self.range, fieldNumber: 2)
    }
    try { if let v = self._fetchPageLimit {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._limit {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HotTopicListRequest, rhs: HotTopicListRequest) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.range != rhs.range {return false}
    if lhs._fetchPageLimit != rhs._fetchPageLimit {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HotTopicListRequest.DateRange: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DAY"),
    1: .same(proto: "WEEK"),
    2: .same(proto: "MONTH"),
  ]
}

extension HotTopicListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "HotTopicListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topics"),
    2: .same(proto: "forum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.topics) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._forum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.topics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topics, fieldNumber: 1)
    }
    try { if let v = self._forum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HotTopicListResponse, rhs: HotTopicListResponse) -> Bool {
    if lhs.topics != rhs.topics {return false}
    if lhs._forum != rhs._forum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForumSearchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ForumSearchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForumSearchRequest, rhs: ForumSearchRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForumSearchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ForumSearchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "forums"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.forums) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.forums.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.forums, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForumSearchResponse, rhs: ForumSearchResponse) -> Bool {
    if lhs.forums != rhs.forums {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FavoriteTopicListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FavoriteTopicListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FavoriteTopicListRequest, rhs: FavoriteTopicListRequest) -> Bool {
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FavoriteTopicListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FavoriteTopicListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topics"),
    2: .same(proto: "pages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.topics) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topics, fieldNumber: 1)
    }
    if self.pages != 0 {
      try visitor.visitSingularUInt32Field(value: self.pages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FavoriteTopicListResponse, rhs: FavoriteTopicListResponse) -> Bool {
    if lhs.topics != rhs.topics {return false}
    if lhs.pages != rhs.pages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TopicFavorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TopicFavorRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "topic_id"),
    2: .same(proto: "operation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topicID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topicID.isEmpty {
      try visitor.visitSingularStringField(value: self.topicID, fieldNumber: 1)
    }
    if self.operation != .add {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TopicFavorRequest, rhs: TopicFavorRequest) -> Bool {
    if lhs.topicID != rhs.topicID {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TopicFavorRequest.Operation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD"),
    1: .same(proto: "DELETE"),
  ]
}

extension TopicFavorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TopicFavorResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_favored"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isFavored) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isFavored != false {
      try visitor.visitSingularBoolField(value: self.isFavored, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TopicFavorResponse, rhs: TopicFavorResponse) -> Bool {
    if lhs.isFavored != rhs.isFavored {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PostReplyFetchContentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PostReplyFetchContentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PostReplyFetchContentRequest, rhs: PostReplyFetchContentRequest) -> Bool {
    if lhs._action != rhs._action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PostReplyFetchContentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PostReplyFetchContentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "subject"),
    3: .same(proto: "verbatim"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._subject) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._verbatim) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    try { if let v = self._subject {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._verbatim {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PostReplyFetchContentResponse, rhs: PostReplyFetchContentResponse) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs._subject != rhs._subject {return false}
    if lhs._verbatim != rhs._verbatim {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PostReplyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PostReplyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "content"),
    3: .same(proto: "subject"),
    4: .same(proto: "attachments"),
    5: .same(proto: "anonymous"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._subject) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.anonymous) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    try { if let v = self._subject {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 4)
    }
    if self.anonymous != false {
      try visitor.visitSingularBoolField(value: self.anonymous, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PostReplyRequest, rhs: PostReplyRequest) -> Bool {
    if lhs._action != rhs._action {return false}
    if lhs.content != rhs.content {return false}
    if lhs._subject != rhs._subject {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.anonymous != rhs.anonymous {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PostReplyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PostReplyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PostReplyResponse, rhs: PostReplyResponse) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FetchNotificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FetchNotificationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FetchNotificationRequest, rhs: FetchNotificationRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FetchNotificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FetchNotificationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.notis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notis.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notis, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FetchNotificationResponse, rhs: FetchNotificationResponse) -> Bool {
    if lhs.notis != rhs.notis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UploadAttachmentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UploadAttachmentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "file"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._action) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.file) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.file.isEmpty {
      try visitor.visitSingularBytesField(value: self.file, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UploadAttachmentRequest, rhs: UploadAttachmentRequest) -> Bool {
    if lhs._action != rhs._action {return false}
    if lhs.file != rhs.file {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UploadAttachmentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UploadAttachmentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attachment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attachment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attachment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UploadAttachmentResponse, rhs: UploadAttachmentResponse) -> Bool {
    if lhs._attachment != rhs._attachment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserTopicListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserTopicListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "author_id"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authorID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authorID.isEmpty {
      try visitor.visitSingularStringField(value: self.authorID, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserTopicListRequest, rhs: UserTopicListRequest) -> Bool {
    if lhs.authorID != rhs.authorID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserTopicListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserTopicListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topics"),
    2: .same(proto: "pages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.topics) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topics, fieldNumber: 1)
    }
    if self.pages != 0 {
      try visitor.visitSingularUInt32Field(value: self.pages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserTopicListResponse, rhs: UserTopicListResponse) -> Bool {
    if lhs.topics != rhs.topics {return false}
    if lhs.pages != rhs.pages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserPostListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserPostListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "author_id"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authorID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authorID.isEmpty {
      try visitor.visitSingularStringField(value: self.authorID, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserPostListRequest, rhs: UserPostListRequest) -> Bool {
    if lhs.authorID != rhs.authorID {return false}
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserPostListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserPostListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserPostListResponse, rhs: UserPostListResponse) -> Bool {
    if lhs.tps != rhs.tps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShortMessageListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ShortMessageListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShortMessageListRequest, rhs: ShortMessageListRequest) -> Bool {
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShortMessageListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ShortMessageListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .same(proto: "pages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    if self.pages != 0 {
      try visitor.visitSingularUInt32Field(value: self.pages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShortMessageListResponse, rhs: ShortMessageListResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.pages != rhs.pages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShortMessageDetailsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ShortMessageDetailsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShortMessageDetailsRequest, rhs: ShortMessageDetailsRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShortMessageDetailsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ShortMessageDetailsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "posts"),
    2: .same(proto: "pages"),
    3: .same(proto: "ids"),
    4: .standard(proto: "user_names"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.posts) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pages) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.userNames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.posts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.posts, fieldNumber: 1)
    }
    if self.pages != 0 {
      try visitor.visitSingularUInt32Field(value: self.pages, fieldNumber: 2)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 3)
    }
    if !self.userNames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userNames, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShortMessageDetailsResponse, rhs: ShortMessageDetailsResponse) -> Bool {
    if lhs.posts != rhs.posts {return false}
    if lhs.pages != rhs.pages {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.userNames != rhs.userNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShortMessagePostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ShortMessagePostRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "content"),
    3: .same(proto: "subject"),
    4: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subject) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 3)
    }
    if !self.to.isEmpty {
      try visitor.visitRepeatedStringField(value: self.to, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShortMessagePostRequest, rhs: ShortMessagePostRequest) -> Bool {
    if lhs._action != rhs._action {return false}
    if lhs.content != rhs.content {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShortMessagePostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ShortMessagePostResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShortMessagePostResponse, rhs: ShortMessagePostResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TopicSearchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TopicSearchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "page"),
    3: .standard(proto: "search_content"),
    4: .standard(proto: "recommended_only"),
    5: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.page) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.searchContent) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.recommendedOnly) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.page != 0 {
      try visitor.visitSingularUInt32Field(value: self.page, fieldNumber: 2)
    }
    if self.searchContent != false {
      try visitor.visitSingularBoolField(value: self.searchContent, fieldNumber: 3)
    }
    if self.recommendedOnly != false {
      try visitor.visitSingularBoolField(value: self.recommendedOnly, fieldNumber: 4)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TopicSearchRequest, rhs: TopicSearchRequest) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.page != rhs.page {return false}
    if lhs.searchContent != rhs.searchContent {return false}
    if lhs.recommendedOnly != rhs.recommendedOnly {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TopicSearchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TopicSearchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topics"),
    2: .same(proto: "pages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.topics) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topics, fieldNumber: 1)
    }
    if self.pages != 0 {
      try visitor.visitSingularUInt32Field(value: self.pages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TopicSearchResponse, rhs: TopicSearchResponse) -> Bool {
    if lhs.topics != rhs.topics {return false}
    if lhs.pages != rhs.pages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClockInRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ClockInRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClockInRequest, rhs: ClockInRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClockInResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ClockInResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .standard(proto: "is_first_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.date) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isFirstTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 1)
    }
    if self.isFirstTime != false {
      try visitor.visitSingularBoolField(value: self.isFirstTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClockInResponse, rhs: ClockInResponse) -> Bool {
    if lhs.date != rhs.date {return false}
    if lhs.isFirstTime != rhs.isFirstTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CacheRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "operation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .all {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.operation != .check {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheRequest, rhs: CacheRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CacheResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
    2: .standard(proto: "total_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.items) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.items != 0 {
      try visitor.visitSingularUInt64Field(value: self.items, fieldNumber: 1)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheResponse, rhs: CacheResponse) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MockApi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MockApi"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "topic_list"),
    2: .standard(proto: "topic_details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: MockApi.TopicList?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .topicList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .topicList(v)
        }
      }()
      case 2: try {
        var v: MockApi.TopicDetails?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .topicDetails(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .topicDetails(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .topicList?: try {
      guard case .topicList(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .topicDetails?: try {
      guard case .topicDetails(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MockApi, rhs: MockApi) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MockApi.TopicList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MockApi.protoMessageName + ".TopicList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MockApi.TopicList, rhs: MockApi.TopicList) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MockApi.TopicDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MockApi.protoMessageName + ".TopicDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MockApi.TopicDetails, rhs: MockApi.TopicDetails) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
